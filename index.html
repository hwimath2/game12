<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>우주 비행기 게임</title>
    <style>
        /* 전체 페이지 스타일링 */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
            position: relative;
            font-family: 'Arial', sans-serif;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* 게임 컨테이너: 전체 화면에 게임 캔버스 배치 */
        .game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* 게임 캔버스: 전체 화면 꽉 채우기 */
        #gameCanvas {
            max-width: 100%;
            max-height: 100%;
            aspect-ratio: 9/16;  /* 모바일 세로 비율 */
            width: auto;
            height: auto;
            touch-action: none;  /* 터치 이벤트 최적화 */
            box-shadow: 0 0 30px rgba(0, 100, 255, 0.7);  /* 더 강한 글로우 효과 */
            opacity: 0; /* 처음에는 완전히 투명하게 시작 */
            transition: opacity 2s ease; /* 전환 효과 2초로 설정 */
        }

        /* 화면 방향에 따른 캔버스 크기 조정 */
        @media (orientation: portrait) {
            #gameCanvas {
                width: 100%;
                height: auto;
            }
        }

        @media (orientation: landscape) {
            #gameCanvas {
                height: 100vh;
                width: auto;
            }
        }

        /* 컨트롤 버튼 컨테이너 */
        .control-buttons {
            position: fixed;
            bottom: 5vh;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            padding: 0 10vw;
            pointer-events: none;
            z-index: 10;
        }

        /* 컨트롤 버튼 스타일 */
        .control-button {
            width: 15vw;
            height: 15vw;
            max-width: 80px;
            max-height: 80px;
            border-radius: 50%;
            background: rgba(0, 150, 255, 0.3);
            border: 2px solid #00a8ff;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            pointer-events: auto;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            cursor: pointer;
            outline: none;
            transition: all 0.2s ease;
            box-shadow: 0 0 15px rgba(0, 150, 255, 0.5);
        }

        /* 버튼 호버 효과 (데스크톱) */
        .control-button:hover {
            background: rgba(0, 150, 255, 0.5);
            transform: scale(1.1);
            box-shadow: 0 0 20px rgba(0, 150, 255, 0.8);
        }

        /* 버튼 활성화 효과 */
        .control-button:active {
            background: rgba(0, 150, 255, 0.7);
            transform: scale(0.95);
        }

        /* 버튼 내 화살표 아이콘 */
        .control-button::before {
            content: attr(data-arrow);
            pointer-events: none;
        }

        /* 재시작 버튼 스타일 */
        #restartBtn {
            display: none;
            position: absolute;
            left: 50%;
            top: 60%;
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            font-size: 32px;
            background: rgba(0, 150, 255, 0.4);
            border: 3px solid #00a8ff;
            color: white;
            border-radius: 50%;
            z-index: 100;
            box-shadow: 0 0 25px rgba(0, 150, 255, 0.7);
            animation: pulse 1.5s infinite;
        }

        /* 재시작 버튼 펄스 애니메이션 */
        @keyframes pulse {
            0% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(0, 150, 255, 0.7);
            }
            70% {
                transform: translate(-50%, -50%) scale(1.05);
                box-shadow: 0 0 0 15px rgba(0, 150, 255, 0);
            }
            100% {
                transform: translate(-50%, -50%) scale(1);
                box-shadow: 0 0 0 0 rgba(0, 150, 255, 0);
            }
        }

        /* 인트로 비디오 컨테이너 스타일 */
        #introContainer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            overflow: hidden;
            opacity: 1;
            transition: opacity 2.5s ease; /* 페이드 효과 2.5초로 설정 */
        }

        /* 인트로 비디오 스타일 */
        #introVideo {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        /* 점수 애니메이션 */
        @keyframes scorePopup {
            0% { transform: scale(1.5); opacity: 1; }
            100% { transform: scale(2.5); opacity: 0; }
        }
    </style>
</head>
<body>
    <!-- 인트로 비디오 (SKIP 버튼 제거) -->
    <div id="introContainer">
        <video id="introVideo" playsinline muted>
            <source src="intro.mp4" type="video/mp4">
            브라우저가 비디오를 지원하지 않습니다.
        </video>
    </div>

    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="control-buttons">
            <!-- 재시작 버튼만 유지 -->
            <button id="restartBtn" class="control-button" data-arrow="↺"></button>
        </div>
    </div>
    
    <script>
        // --- 인트로 비디오 처리 ---
        const introContainer = document.getElementById("introContainer");
        const introVideo = document.getElementById("introVideo");
        const canvas = document.getElementById("gameCanvas");

        // 인트로 비디오 재생 시작
        let introPlayed = false;
        let transitionStarted = false;
        
        function playIntro() {
          // 자동 재생 시도 (모바일 기기에서는 제한이 있을 수 있음)
          introVideo.play().catch(error => {
            console.error("비디오 자동 재생 실패:", error);
            // 자동 재생 정책으로 인해 실패한 경우 클릭 요청 표시
            showPlayPrompt();
          });
          
          // 5초 영상이면 2.5초 정도에 페이드 아웃 시작
          introVideo.addEventListener('timeupdate', function() {
            // 영상 길이 확인
            const videoDuration = introVideo.duration;
            // 영상 현재 시간
            const currentTime = introVideo.currentTime;
            
            // 영상의 절반 지점에서 페이드 아웃 시작
            if (currentTime >= videoDuration * 0.5 && !transitionStarted) {
              transitionStarted = true;
              startFadeTransition();
            }
          });
        }
        
        // 자동 재생 실패 시 클릭 요청 표시
        function showPlayPrompt() {
          const playPrompt = document.createElement('div');
          playPrompt.style.position = 'absolute';
          playPrompt.style.top = '50%';
          playPrompt.style.left = '50%';
          playPrompt.style.transform = 'translate(-50%, -50%)';
          playPrompt.style.color = 'white';
          playPrompt.style.fontSize = '24px';
          playPrompt.style.textAlign = 'center';
          playPrompt.style.cursor = 'pointer';
          playPrompt.style.padding = '20px';
          playPrompt.style.background = 'rgba(0, 0, 0, 0.5)';
          playPrompt.style.borderRadius = '10px';
          playPrompt.style.zIndex = '2001';
          playPrompt.innerHTML = '화면을 클릭하여 시작하세요';
          
          introContainer.appendChild(playPrompt);
          
          // 화면 클릭 시 영상 재생
          introContainer.addEventListener('click', function clickHandler() {
            introVideo.play().catch(e => console.error("사용자 클릭 후에도 재생 실패:", e));
            playPrompt.remove();
            introContainer.removeEventListener('click', clickHandler);
          }, { once: true });
        }

        // 페이드 트랜지션 시작
        function startFadeTransition() {
          if (introPlayed) return; // 중복 실행 방지
          introPlayed = true;
          
          // 인트로 비디오 페이드 아웃 - 2.5초 동안 진행
          introContainer.style.opacity = "0";
          
          // 이미지 프리로드 시작
          setTimeout(() => {
            checkImagesLoaded();
          }, 2000); // 2초 후 이미지 로딩 시작 (영상이 완전히 투명해진 이후)
        }
        
        // 비디오 종료 이벤트 (자동 처리를 위해 남겨둠)
        introVideo.addEventListener("ended", () => {
          if (!transitionStarted) {
            startFadeTransition();
          }
        });

        // --- 1) 이미지 프리로드 ---
        const ASSETS = {
          bg:    "background.png",
          p:     "player.png",
          e1:    "enemy1.png",
          e2:    "enemy2.png",
          h1:    "health_item1.png",
          h2:    "health_item2.png",
          expl1: "explosion1.png",
          expl2: "explosion2.png",
          expl3: "explosion3.png",
          expl4: "explosion4.png",
          expl5: "explosion5.png",
          missile: "missile.png"
        };
        const IMG = {};
        let loadedCount = 0;
        const TOTAL_ASSETS = Object.keys(ASSETS).length;

        // 이미지 로딩 상태 확인 함수
        function checkImagesLoaded() {
          // 인트로 컨테이너 완전히 제거 (z-index 영향 없애기)
          setTimeout(() => {
            introContainer.style.display = "none";
          }, 500);
          
          for (const key in ASSETS) {
            IMG[key] = new Image();
            IMG[key].src = ASSETS[key];
            IMG[key].onload = () => {
              if (++loadedCount === TOTAL_ASSETS) initGame();
            };
            IMG[key].onerror = () => {
              console.log("이미지 로드 실패: ", ASSETS[key]);
              // 이미지 로드 실패해도 게임 시작하도록 처리
              if (++loadedCount === TOTAL_ASSETS) initGame();
            };
          }
          
          // 모든 이미지가 아직, 로드되지 않았다면 5초 후 강제 시작
          setTimeout(function() {
            if (!gameOver && !player) {
              console.log("강제 게임 시작");
              initGame();
            }
          }, 5000);
        }

        // --- 2) 캔버스 설정 ---
        const ctx = canvas.getContext("2d");
        canvas.width  = 800;
        canvas.height = 600;

        // --- 3) 상수 정의 ---
        const PLAYER_SIZE   = 130;
        const ENEMY_SIZE    = 110;    // 적 크기
        const ITEM_SIZE     = 110;
        const ITEM_INTERVAL = 10000; // 10초마다 아이템
        const BASE_SHOT_INT = 500;   // 자동 발사 기본 간격(ms)
        const SPEED_FACTOR  = 0.02;  // 적 속도 증가 비율 (초당)
        const MOVE_SPEED    = 8;     // 기본 이동 속도

        // --- 4) 상태 변수 ---
        let player, enemies, missiles, items, explosions, scorePopups;
        let playerEnergy, score, gameOver;
        let missileCount, missilePickups, shotInterval;
        let lastItemTime, lastShotTime, startTime;
        let canvasAspectRatio = canvas.width / canvas.height; // 캔버스 비율 계산
        let moveSpeedX = MOVE_SPEED; // 기본 X축 이동 속도
        let moveSpeedY = MOVE_SPEED; // 기본 Y축 이동 속도
        let canvasXRatio = 1; // 캔버스 X 축 비율
        let canvasYRatio = 1; // 캔버스 Y 축 비율

        // 터치/마우스 위치 변수
        let touchX = null;
        let touchY = null;
        let lastTouchX = null; // 이전 터치 X 위치
        let lastTouchY = null; // 이전 터치 Y 위치
        let isTouching = false;
        let touchMoveDistance = 0; // 터치 움직임 거리
        
        // 캔버스 크기와 실제 표시되는 크기 비율 계산 함수
        function updateCanvasRatio() {
            const canvasRect = canvas.getBoundingClientRect();
            const displayWidth = canvasRect.width;
            const displayHeight = canvasRect.height;
            
            // 실제 캔버스 크기와 화면에 표시되는 크기의 비율 계산
            canvasXRatio = canvas.width / displayWidth;
            canvasYRatio = canvas.height / displayHeight;
            
            // 화면 비율에 따라 이동 속도 조정
            if (canvasXRatio > canvasYRatio) {
                // 너비가 상대적으로 더 크게 줄어든 경우 (가로가 더 넓게 보임)
                moveSpeedX = MOVE_SPEED * (canvasYRatio / canvasXRatio);
                moveSpeedY = MOVE_SPEED;
            } else {
                // 높이가 상대적으로 더 크게 줄어든 경우 (세로가 더 높게 보임)
                moveSpeedX = MOVE_SPEED;
                moveSpeedY = MOVE_SPEED * (canvasXRatio / canvasYRatio);
            }
            
            console.log(`Canvas ratio - X: ${canvasXRatio}, Y: ${canvasYRatio}`);
            console.log(`Move speed - X: ${moveSpeedX}, Y: ${moveSpeedY}`);
        }

        // --- 5) 키 입력 & 버튼 이벤트 ---
        const keys = {};
        window.addEventListener("keydown", e => keys[e.key] = true);
        window.addEventListener("keyup",   e => keys[e.key] = false);

        // 재시작 버튼 이벤트 리스너
        const restartBtn = document.getElementById("restartBtn");
        if (restartBtn) {
          restartBtn.addEventListener("click", function() {
            this.style.display = "none";
            initGame();
          });
        }

        // 터치/마우스 이벤트 리스너
        canvas.addEventListener("touchstart", handleTouchStart, { passive: false });
        canvas.addEventListener("touchmove", handleTouchMove, { passive: false });
        canvas.addEventListener("touchend", handleTouchEnd);
        canvas.addEventListener("mousedown", handleMouseDown);
        canvas.addEventListener("mousemove", handleMouseMove);
        canvas.addEventListener("mouseup", handleMouseUp);
        
        // 화면 리사이즈 이벤트
        window.addEventListener("resize", updateCanvasRatio);

        function handleTouchStart(e) {
          e.preventDefault();
          isTouching = true;
          const touch = e.touches[0];
          const rect = canvas.getBoundingClientRect();
          touchX = touch.clientX - rect.left;
          touchY = touch.clientY - rect.top;
          
          // 좌표 변환: 화면 좌표를 캔버스 좌표로 변환
          const canvasX = (touchX * canvas.width) / rect.width;
          const canvasY = (touchY * canvas.height) / rect.height;
          
          // 이전 위치 저장 (첫 터치)
          lastTouchX = canvasX;
          lastTouchY = canvasY;
          
          // 터치 위치로 즉시 이동
          player.x = canvasX - player.w / 2;
          player.y = canvasY - player.h / 2;
          
          // 경계 확인
          player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
          player.y = Math.max(0, Math.min(canvas.height - player.h, player.y));
          
          touchMoveDistance = 0;
        }

        function handleTouchMove(e) {
          if (!isTouching) return;
          e.preventDefault();
          const touch = e.touches[0];
          const rect = canvas.getBoundingClientRect();
          
          // 이전 터치 위치 저장
          const prevX = touchX;
          const prevY = touchY;
          
          // 새 터치 위치 업데이트
          touchX = touch.clientX - rect.left;
          touchY = touch.clientY - rect.top;
          
          // 좌표 변환: 화면 좌표를 캔버스 좌표로 변환
          const canvasX = (touchX * canvas.width) / rect.width;
          const canvasY = (touchY * canvas.height) / rect.height;
          
          // 이전 터치와의 거리 계산
          if (lastTouchX !== null && lastTouchY !== null) {
            const deltaX = canvasX - lastTouchX;
            const deltaY = canvasY - lastTouchY;
            
            // 비율에 맞게 이동 속도 적용
            player.x += deltaX;
            player.y += deltaY;
            
            // 경계 확인
            player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
            player.y = Math.max(0, Math.min(canvas.height - player.h, player.y));
            
            // 움직인 거리 누적
            touchMoveDistance += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          }
          
          // 현재 위치를 다음 계산을 위해 저장
          lastTouchX = canvasX;
          lastTouchY = canvasY;
        }

        function handleTouchEnd() {
          isTouching = false;
          lastTouchX = null;
          lastTouchY = null;
        }

        function handleMouseDown(e) {
          isTouching = true;
          const rect = canvas.getBoundingClientRect();
          touchX = e.clientX - rect.left;
          touchY = e.clientY - rect.top;
          
          // 좌표 변환: 화면 좌표를 캔버스 좌표로 변환
          const canvasX = (touchX * canvas.width) / rect.width;
          const canvasY = (touchY * canvas.height) / rect.height;
          
          // 이전 위치 저장 (첫 클릭)
          lastTouchX = canvasX;
          lastTouchY = canvasY;
          
          // 클릭 위치로 즉시 이동
          player.x = canvasX - player.w / 2;
          player.y = canvasY - player.h / 2;
          
          // 경계 확인
          player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
          player.y = Math.max(0, Math.min(canvas.height - player.h, player.y));
          
          touchMoveDistance = 0;
        }

        function handleMouseMove(e) {
          if (!isTouching) return;
          const rect = canvas.getBoundingClientRect();
          
          // 이전 마우스 위치 저장
          const prevX = touchX;
          const prevY = touchY;
          
          // 새 마우스 위치 업데이트
          touchX = e.clientX - rect.left;
          touchY = e.clientY - rect.top;
          
          // 좌표 변환: 화면 좌표를 캔버스 좌표로 변환
          const canvasX = (touchX * canvas.width) / rect.width;
          const canvasY = (touchY * canvas.height) / rect.height;
          
          // 이전 터치와의 거리 계산
          if (lastTouchX !== null && lastTouchY !== null) {
            const deltaX = canvasX - lastTouchX;
            const deltaY = canvasY - lastTouchY;
            
            // 비율에 맞게 이동 속도 적용
            player.x += deltaX;
            player.y += deltaY;
            
            // 경계 확인
            player.x = Math.max(0, Math.min(canvas.width - player.w, player.x));
            player.y = Math.max(0, Math.min(canvas.height - player.h, player.y));
            
            // 움직인 거리 누적
            touchMoveDistance += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          }
          
          // 현재 위치를 다음 계산을 위해 저장
          lastTouchX = canvasX;
          lastTouchY = canvasY;
        }

        function handleMouseUp() {
          isTouching = false;
          lastTouchX = null;
          lastTouchY = null;
        }

        window.addEventListener("keydown", e => {
          if (e.key === " ") shootMissile();
        });

        // --- 6) 클래스 정의 ---
        class Player {
          constructor() {
            this.w  = PLAYER_SIZE;
            this.h  = PLAYER_SIZE;
            this.x  = canvas.width/2 - this.w/2;
            this.y  = canvas.height - this.h - 10;
            this.trail = []; // 비행기 후광 효과
          }
          
          move() {
            // 이전 위치를 트레일에 추가
            if (this.trail.length > 5) {
              this.trail.shift(); // 오래된 위치 제거
            }
            this.trail.push({x: this.x, y: this.y});
            
            // 키보드로 이동 (상하좌우 균등한 속도로)
            if (keys["ArrowLeft"] && this.x > 0)
              this.x -= moveSpeedX;
            if (keys["ArrowRight"] && this.x < canvas.width - this.w)
              this.x += moveSpeedX;
            if (keys["ArrowUp"] && this.y > 0)
              this.y -= moveSpeedY;
            if (keys["ArrowDown"] && this.y < canvas.height - this.h)
              this.y += moveSpeedY;
            
            // 터치/마우스는 handleTouchMove와 handleMouseMove에서 처리됨
          }
          
          draw() {
            // 비행기 후광 그리기
            this.trail.forEach((pos, i) => {
              const alpha = i / 5; // 위치가 오래될수록 더 투명하게
              if (IMG.p && IMG.p.complete) {
                ctx.globalAlpha = alpha * 0.3;
                ctx.drawImage(IMG.p, pos.x, pos.y, this.w, this.h);
              }
            });
            ctx.globalAlpha = 1;
            
            // 이미지가 로드 안됐으면 기본 사각형으로 표시
            if (IMG.p && IMG.p.complete) {
              ctx.drawImage(IMG.p, this.x, this.y, this.w, this.h);
              
              // 엔진 불꽃 효과
              ctx.fillStyle = "rgba(255, 100, 0, 0.7)";
              const flameHeight = 10 + Math.random() * 10; // 불규칙한 불꽃 높이
              ctx.beginPath();
              ctx.moveTo(this.x + this.w * 0.4, this.y + this.h);
              ctx.lineTo(this.x + this.w * 0.5, this.y + this.h + flameHeight);
              ctx.lineTo(this.x + this.w * 0.6, this.y + this.h);
              ctx.fill();
            } else {
              ctx.fillStyle = "blue";
              ctx.fillRect(this.x, this.y, this.w, this.h);
            }
          }
        }

        class Missile {
          constructor(x, y, ang = 0) {
            this.x = x;
            this.y = y;
            this.w = 8;
            this.h = 16;
            this.sp = 8;
            this.ang = ang * Math.PI/180;
            this.trail = []; // 미사일 궤적
          }
          
          move() {
            // 이전 위치 저장
            this.trail.push({x: this.x, y: this.y});
            if (this.trail.length > 5) {
              this.trail.shift();
            }
            
            this.y -= this.sp;
            this.x += Math.sin(this.ang) * 5;
          }
          
          draw() {
            // 미사일 궤적 그리기 (반투명한 잔상)
            for (let i = 0; i < this.trail.length; i++) {
              const t = this.trail[i];
              const alpha = i / 5; // 이전 위치일수록 더 투명하게
              
              // 미사일 이미지가 있으면 이미지로, 없으면 도형으로
              if (IMG.missile && IMG.missile.complete) {
                ctx.globalAlpha = alpha * 0.5;
                ctx.drawImage(IMG.missile, t.x, t.y, this.w, this.h);
              } else {
                ctx.globalAlpha = alpha * 0.5;
                ctx.fillStyle = "#ff5500";
                ctx.fillRect(t.x, t.y, this.w, this.h);
              }
            }
            
            // 현재 미사일 그리기
            ctx.globalAlpha = 1;
            if (IMG.missile && IMG.missile.complete) {
              ctx.drawImage(IMG.missile, this.x, this.y, this.w, this.h);
            } else {
              ctx.fillStyle = "red";
              ctx.fillRect(this.x, this.y, this.w, this.h);
            }
            
            // 미사일 광원 효과
            ctx.globalAlpha = 0.3;
            const grd = ctx.createRadialGradient(
              this.x + this.w/2, this.y + this.h/2, 1,
              this.x + this.w/2, this.y + this.h/2, 10
            );
            grd.addColorStop(0, "rgba(255, 200, 50, 0.8)");
            grd.addColorStop(1, "rgba(255, 100, 0, 0)");
            ctx.fillStyle = grd;
            ctx.beginPath();
            ctx.arc(this.x + this.w/2, this.y + this.h/2, 10, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }
        }

        class Enemy {
          constructor(type) {
            this.w      = ENEMY_SIZE;
            this.h      = ENEMY_SIZE;
            this.x      = Math.random() * (canvas.width - this.w);
            this.y      = -this.h;
            this.type   = type;       // 1 또는 2
            this.health = type;       // 체력: 1 or 2
            this.baseSp = 1;          // 기본 속도
          }
          move(now) {
            const elapsed = (now - startTime) / 1000;
            const speed   = this.baseSp + elapsed * SPEED_FACTOR;
            this.y += speed;
          }
          draw() {
            // 이미지가 로드 안됐으면 기본 사각형으로 표시
            const img = this.type === 1 ? IMG.e1 : IMG.e2;
            if (img && img.complete) {
              ctx.drawImage(img, this.x, this.y, this.w, this.h);
            } else {
              ctx.fillStyle = this.type === 1 ? "purple" : "darkred";
              ctx.fillRect(this.x, this.y, this.w, this.h);
            }
          }
        }

        class Item {
          constructor() {
            this.w    = ITEM_SIZE;
            this.h    = ITEM_SIZE;
            this.x    = Math.random() * (canvas.width - this.w);
            this.y    = -this.h;
            this.sp   = 3;
            this.type = Math.random() < 0.5 ? "health" : "missile";
            this.angle = 0; // 회전 애니메이션용
            this.scale = 1; // 크기 애니메이션용
            this.scaleDir = 0.005; // 크기 변화 방향
          }
          move() {
            this.y += this.sp;
            
            // 회전 애니메이션
            this.angle += 0.02;
            
            // 크기 애니메이션 (살짝 펄싱)
            this.scale += this.scaleDir;
            if (this.scale > 1.1) this.scaleDir = -0.005;
            if (this.scale < 0.9) this.scaleDir = 0.005;
          }
          draw() {
            ctx.save();
            // 아이템 중심 기준 회전 및 크기 조정
            ctx.translate(this.x + this.w/2, this.y + this.h/2);
            ctx.rotate(this.angle);
            ctx.scale(this.scale, this.scale);
            
            // 이미지가 로드 안됐으면 기본 사각형으로 표시
            const img = this.type === "health" ? IMG.h1 : IMG.h2;
            if (img && img.complete) {
              ctx.drawImage(img, -this.w/2, -this.h/2, this.w, this.h);
            } else {
              ctx.fillStyle = this.type === "health" ? "green" : "orange";
              ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
            }
            
            // 아이템 주변 글로우 효과
            const glowColor = this.type === "health" ? 
                "rgba(0, 255, 0, 0.3)" : "rgba(255, 150, 0, 0.3)";
            ctx.shadowColor = this.type === "health" ? "#00ff00" : "#ff9600";
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(0, 0, this.w/2, 0, Math.PI*2);
            ctx.fillStyle = glowColor;
            ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.restore();
        }
        }
        
        // 폭발 애니메이션 클래스
        class Explosion {
          constructor(x, y, size) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.frame = 0;
            this.totalFrames = 5; // 5개 프레임 애니메이션
            this.frameWidth = 192; // 폭발 스프라이트 한 프레임 너비
            this.frameHeight = 192; // 폭발 스프라이트 한 프레임 높이
            this.frameDelay = 3; // 각 프레임 지속 시간
            this.frameCounter = 0;
            this.complete = false;
          }
          
          update() {
            this.frameCounter++;
            if (this.frameCounter >= this.frameDelay) {
              this.frameCounter = 0;
              this.frame++;
              if (this.frame >= this.totalFrames) {
                this.complete = true;
              }
            }
          }
          
          draw() {
            if (this.complete) return;
            
            // 폭발 이미지 그리기
            const explosionImg = `expl${this.frame + 1}`;
            
            if (IMG[explosionImg] && IMG[explosionImg].complete) {
              ctx.drawImage(
                IMG[explosionImg],
                this.x - this.size/2,
                this.y - this.size/2,
                this.size,
                this.size
              );
            } else {
              // 이미지가 없으면 원으로 표시
              ctx.fillStyle = `rgba(255, ${255 - this.frame * 50}, 0, ${1 - this.frame/this.totalFrames})`;
              ctx.beginPath();
              ctx.arc(this.x, this.y, this.size/2 * (1 + this.frame/this.totalFrames), 0, Math.PI*2);
              ctx.fill();
            }
          }
        }
        
        // 점수 팝업 효과 클래스
        class ScorePopup {
          constructor(x, y, value) {
            this.x = x;
            this.y = y;
            this.value = value;
            this.lifetime = 30; // 표시 지속 프레임
            this.alpha = 1;
            this.scale = 1;
          }
          
          update() {
            this.lifetime--;
            this.y -= 1;
            this.alpha = this.lifetime / 30;
            this.scale += 0.03;
          }
          
          draw() {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.font = `bold ${Math.floor(24 * this.scale)}px Arial`;
            ctx.fillStyle = "yellow";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.textAlign = "center";
            ctx.strokeText(`+${this.value}`, this.x, this.y);
            ctx.fillText(`+${this.value}`, this.x, this.y);
            ctx.restore();
          }
        }

        // --- 7) 충돌 검사 & 발사 함수 ---
        function isCollision(a, b) {
          return a.x < b.x + b.w &&
                 a.x + a.w > b.x &&
                 a.y < b.y + b.h &&
                 a.y + a.h > b.y;
        }
        
        function shootMissile() {
          const sx = player.x + player.w/2 - 4;
          const sy = player.y;
          
          // 발사 이펙트
          drawMuzzleFlash(sx + 4, sy);
          
          if (missileCount === 1) {
            missiles.push(new Missile(sx, sy));
          } else {
            for (let i = 0; i < missileCount; i++) {
              const ang = (i - (missileCount-1)/2) * 15;
              missiles.push(new Missile(sx, sy, ang));
            }
          }
        }
        
        // 미사일 발사 플래시 효과
        function drawMuzzleFlash(x, y) {
          // 발사 순간의 빛 효과
          const flash = ctx.createRadialGradient(x, y, 1, x, y, 30);
          flash.addColorStop(0, "rgba(255, 255, 200, 1)");
          flash.addColorStop(0.3, "rgba(255, 150, 50, 0.5)");
          flash.addColorStop(1, "rgba(255, 100, 0, 0)");
          
          ctx.globalAlpha = 0.7;
          ctx.fillStyle = flash;
          ctx.beginPath();
          ctx.arc(x, y, 30, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // --- 8) 게임 초기화 ---
        function initGame() {
          player         = new Player();
          enemies        = [];
          missiles       = [];
          items          = [];
          explosions     = [];
          scorePopups    = [];
          playerEnergy   = 100;
          score          = 0;
          gameOver       = false;
          missileCount   = 1;
          missilePickups = 0;
          shotInterval   = BASE_SHOT_INT;
          startTime      = performance.now();
          lastItemTime   = startTime;
          lastShotTime   = startTime;
          
          // 화면 비율에 따른 이동 속도 조정
          updateCanvasRatio();
          
          // 게임 캔버스 페이드 인 시작 - 2초에 걸쳐 천천히 나타나기
          setTimeout(() => {
            canvas.style.opacity = "1";
          }, 500); // 약간의 지연 후 페이드 인 시작
          
          // 재시작 버튼 숨기기
          if (restartBtn) {
            restartBtn.style.display = "none";
          }
          
          // 게임 시작
          requestAnimationFrame(gameLoop);
        }

        // --- 9) 화면 그리기 헬퍼 ---
        function drawBackground() {
          // 배경 이미지가 로드 안됐으면 기본 사각형으로 표시
          if (IMG.bg && IMG.bg.complete) {
            ctx.drawImage(IMG.bg, 0, 0, canvas.width, canvas.height);
          } else {
            // 그라데이션 배경
            const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, "#000020");
            bgGradient.addColorStop(1, "#000000");
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 별 그리기
            ctx.fillStyle = "white";
            for (let i = 0; i < 100; i++) {
              const starSize = Math.random() * 2 + 1;
              const starX = Math.random() * canvas.width;
              const starY = Math.random() * canvas.height;
              const brightness = Math.random() * 0.5 + 0.5;
              
              ctx.globalAlpha = brightness;
              ctx.beginPath();
              ctx.arc(starX, starY, starSize/2, 0, Math.PI*2);
              ctx.fill();
            }
            ctx.globalAlpha = 1;
          }
        }
        
        function drawUI() {
          // 체력 게이지 그리기 - 현대적인 디자인
          const energyBarX = 20;
          const energyBarY = 20;
          const energyBarWidth = 200;
          const energyBarHeight = 25;
          
          // 외부 테두리
          ctx.fillStyle = "rgba(30, 30, 30, 0.7)";
          ctx.strokeStyle = "#0088ff";
          ctx.lineWidth = 2;
          roundRect(ctx, energyBarX, energyBarY, energyBarWidth, energyBarHeight, 5, true, true);
          
          // 체력 바 배경
          ctx.fillStyle = "rgba(50, 50, 50, 0.7)";
          roundRect(ctx, energyBarX + 3, energyBarY + 3, energyBarWidth - 6, energyBarHeight - 6, 3, true, false);
          
          // 체력 값에 따라 색상 변경
          let barColor;
          if (playerEnergy > 60) {
            barColor = "#00ff88"; // 높은 체력: 녹색
          } else if (playerEnergy > 30) {
            barColor = "#ffff00"; // 중간 체력: 노란색
          } else {
            barColor = "#ff3300"; // 낮은 체력: 빨간색
            
            // 위험할 때 깜빡임 효과
            if (Math.floor(performance.now() / 200) % 2 === 0) {
              barColor = "#ff6600";
            }
          }
          
          // 체력 바
          const energyWidth = (playerEnergy / 100) * (energyBarWidth - 6);
          ctx.fillStyle = barColor;
          roundRect(ctx, energyBarX + 3, energyBarY + 3, energyWidth, energyBarHeight - 6, 3, true, false);
          
          // 체력 텍스트
          ctx.font = "bold 16px Arial";
          ctx.fillStyle = "white";
          ctx.textAlign = "center";
          ctx.fillText(`${playerEnergy}%`, energyBarX + energyBarWidth / 2, energyBarY + energyBarHeight / 2 + 5);
          
          // 점수 표시
          ctx.font = "bold 28px Arial";
          ctx.textAlign = "right";
          ctx.fillStyle = "#ffcc00";
          ctx.strokeStyle = "black";
          ctx.lineWidth = 3;
          ctx.strokeText(`점수: ${score}`, canvas.width - 20, 40);
          ctx.fillText(`점수: ${score}`, canvas.width - 20, 40);
          
          // 미사일 업그레이드 표시
          const missileIconX = canvas.width - 150;
          const missileIconY = 60;
          
          ctx.font = "bold 18px Arial";
          ctx.fillStyle = "#ffaa00";
          ctx.textAlign = "left";
          ctx.fillText("미사일: ", missileIconX, missileIconY);
          
          // 미사일 아이콘으로 현재 미사일 레벨 표시
          for (let i = 0; i < missileCount; i++) {
            ctx.fillStyle = "#ff5500";
            ctx.fillRect(missileIconX + 80 + i * 20, missileIconY - 15, 5, 15);
            
            // 미사일 꼬리 효과
            ctx.fillStyle = "rgba(255, 100, 0, 0.7)";
            ctx.beginPath();
            ctx.moveTo(missileIconX + 80 + i * 20, missileIconY);
            ctx.lineTo(missileIconX + 80 + i * 20 + 5, missileIconY);
            ctx.lineTo(missileIconX + 82.5 + i * 20, missileIconY + 5);
            ctx.fill();
          }
          
          // 발사 속도 표시
          const shotSpeedX = canvas.width - 150;
          const shotSpeedY = 90;
          
          ctx.fillStyle = "#00ccff";
          ctx.textAlign = "left";
          ctx.fillText("발사 속도: ", shotSpeedX, shotSpeedY);
          
          // 발사 속도 바
          const speedBarWidth = 70;
          const speedBarHeight = 10;
          ctx.fillStyle = "rgba(50, 50, 50, 0.7)";
          ctx.fillRect(shotSpeedX + 80, shotSpeedY - 10, speedBarWidth, speedBarHeight);
          
          // 발사 속도 값 (BASE_SHOT_INT에서 역산)
          const speedRatio = BASE_SHOT_INT / shotInterval;
          ctx.fillStyle = "#00aaff";
          ctx.fillRect(shotSpeedX + 80, shotSpeedY - 10, speedBarWidth * speedRatio/2, speedBarHeight);
        }
        
        // 둥근 사각형 그리기 함수
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
          if (typeof radius === 'undefined') {
            radius = 5;
          }
          ctx.beginPath();
          ctx.moveTo(x + radius, y);
          ctx.lineTo(x + width - radius, y);
          ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
          ctx.lineTo(x + width, y + height - radius);
          ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
          ctx.lineTo(x + radius, y + height);
          ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
          ctx.lineTo(x, y + radius);
          ctx.quadraticCurveTo(x, y, x + radius, y);
          ctx.closePath();
          if (fill) {
            ctx.fill();
          }
          if (stroke) {
            ctx.stroke();
          }
        }

        // --- 10) 메인 루프 ---
        function gameLoop(now) {
          // 1) 배경 & UI
          drawBackground();
          
          // 2) 자동 미사일 발사
          if (now - lastShotTime >= shotInterval) {
            shootMissile();
            lastShotTime = now;
          }

          // 3) 플레이어
          player.move();
          player.draw();

          // 4) 적 스폰
          if (Math.random() < 0.02) {
            enemies.push(new Enemy(Math.random() < 0.5 ? 1 : 2));
          }

          // 5) 아이템 10초마다 스폰
          if (now - lastItemTime >= ITEM_INTERVAL) {
            items.push(new Item());
            lastItemTime = now;
          }

          // 6) 적 처리
          for (let i = enemies.length-1; i >= 0; i--) {
            const e = enemies[i];
            e.move(now);
            e.draw();
            if (e.y > canvas.height) { enemies.splice(i, 1); continue; }

            if (isCollision(player, e)) {
              playerEnergy -= 20;
              enemies.splice(i, 1);
              // 충돌 폭발 효과
              explosions.push(new Explosion(e.x + e.w/2, e.y + e.h/2, e.w * 1.5));
              if (playerEnergy <= 0) gameOver = true;
              continue;
            }
            for (let j = missiles.length-1; j >= 0; j--) {
              if (isCollision(missiles[j], e)) {
                missiles.splice(j, 1);
                e.health--;
                if (e.health <= 0) {
                  score++;
                  // 폭발 효과 추가
                  explosions.push(new Explosion(e.x + e.w/2, e.y + e.h/2, e.w * 1.5));
                  // 점수 팝업 효과
                  scorePopups.push(new ScorePopup(e.x + e.w/2, e.y, 1));
                  enemies.splice(i, 1);
                }
                break;
              }
            }
          }

          // 7) 아이템 처리
          for (let i = items.length-1; i >= 0; i--) {
            const it = items[i];
            it.move();
            it.draw();
            if (it.y > canvas.height) { items.splice(i, 1); continue; }

            if (isCollision(player, it)) {
              if (it.type === "health") {
                playerEnergy = Math.min(100, playerEnergy + 30);
                // 체력 획득 팝업
                scorePopups.push(new ScorePopup(it.x + it.w/2, it.y, "HP+30"));
              } else {
                missilePickups = Math.min(3, missilePickups + 1);
                if (missilePickups === 1) {
                  shotInterval = BASE_SHOT_INT / 2;
                  scorePopups.push(new ScorePopup(it.x + it.w/2, it.y, "속도↑"));
                } else if (missilePickups === 2) {
                  missileCount = 2;
                  scorePopups.push(new ScorePopup(it.x + it.w/2, it.y, "2연발"));
                } else if (missilePickups === 3) {
                  missileCount = 3;
                  scorePopups.push(new ScorePopup(it.x + it.w/2, it.y, "3연발"));
                }
              }
              items.splice(i, 1);
            }
          }

          // 8) 미사일 처리
          for (let i = missiles.length-1; i >= 0; i--) {
            missiles[i].move();
            missiles[i].draw();
            if (missiles[i].y < -missiles[i].h) missiles.splice(i, 1);
          }
          
          // 9) 폭발 이펙트 처리
          for (let i = explosions.length-1; i >= 0; i--) {
            explosions[i].update();
            explosions[i].draw();
            if (explosions[i].complete) {
              explosions.splice(i, 1);
            }
          }
          
          // 10) 점수 팝업 처리
          for (let i = scorePopups.length-1; i >= 0; i--) {
            scorePopups[i].update();
            scorePopups[i].draw();
            if (scorePopups[i].lifetime <= 0) {
              scorePopups.splice(i, 1);
            }
          }
          
          // 11) UI 표시 (다른 요소 위에 그리기)
          drawUI();

          // 12) 게임 오버
          if (gameOver) {
            // 검은색 반투명 배경
            ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 게임 오버 텍스트 (그라데이션)
            const txtGradient = ctx.createLinearGradient(
              canvas.width/2 - 100, canvas.height/2 - 40,
              canvas.width/2 + 100, canvas.height/2
            );
            txtGradient.addColorStop(0, "#ff3300");
            txtGradient.addColorStop(0.5, "#ffcc00");
            txtGradient.addColorStop(1, "#ff3300");
            
            ctx.font = "bold 50px Arial";
            ctx.textAlign = "center";
            ctx.fillStyle = txtGradient;
            ctx.strokeStyle = "black";
            ctx.lineWidth = 3;
            ctx.strokeText("게임 오버!", canvas.width/2, canvas.height/2 - 40);
            ctx.fillText("게임 오버!", canvas.width/2, canvas.height/2 - 40);
            
            // 최종 점수
            ctx.font = "bold 35px Arial";
            ctx.fillStyle = "#ffffff";
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.strokeText(`최종 점수: ${score}`, canvas.width/2, canvas.height/2);
            ctx.fillText(`최종 점수: ${score}`, canvas.width/2, canvas.height/2);
            
            // 재시작 버튼 표시
            if (restartBtn) {
              restartBtn.style.display = "flex";
              restartBtn.style.position = "absolute";
              restartBtn.style.left = "50%";
              restartBtn.style.top = "60%";
              restartBtn.style.transform = "translate(-50%, -50%)";
              restartBtn.style.fontSize = "32px";
              restartBtn.style.width = "120px";
              restartBtn.style.height = "120px";
            }
            
            return; // 루프 완전 종료
          }

          // 13) 다음 프레임
          requestAnimationFrame(gameLoop);
        }

        // 페이지 로드 완료 시 인트로 시작
        window.addEventListener('load', function() {
          console.log("페이지 로드 완료");
          playIntro();
        });
    </script>
</body>
</html>
